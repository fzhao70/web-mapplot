<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{TITLE}}</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet MiniMap CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-minimap/3.6.1/Control.MiniMap.min.css" />

    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-header: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --text-primary: #333;
            --text-secondary: #666;
            --border-color: #ddd;
            --border-light: #eee;
            --button-primary: #667eea;
            --button-primary-hover: #5568d3;
            --button-secondary: #6c757d;
            --button-secondary-hover: #5a6268;
            --info-bg: #e7f3ff;
            --info-border: #667eea;
            --shadow: rgba(0,0,0,0.1);
            --shadow-strong: rgba(0,0,0,0.2);
            --slider-thumb: #667eea;
            --leaflet-bg: #aad3df;
            --input-bg: #ffffff;
            --control-panel-bg: rgba(255, 255, 255, 0.85);
            --control-panel-border: rgba(221, 221, 221, 0.5);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-header: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --border-color: #404040;
            --border-light: #353535;
            --button-primary: #5a67d8;
            --button-primary-hover: #4c51bf;
            --button-secondary: #4a5568;
            --button-secondary-hover: #2d3748;
            --info-bg: #2a4365;
            --info-border: #4299e1;
            --shadow: rgba(0,0,0,0.3);
            --shadow-strong: rgba(0,0,0,0.5);
            --slider-thumb: #5a67d8;
            --leaflet-bg: #1a2332;
            --input-bg: #2d2d2d;
            --control-panel-bg: rgba(26, 26, 26, 0.85);
            --control-panel-border: rgba(64, 64, 64, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
        }

        #header {
            background: var(--bg-header);
            color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 10px var(--shadow);
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #auto-refresh-indicator {
            display: none;
            background: rgba(255, 255, 255, 0.2);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            color: white;
        }

        #auto-refresh-indicator.active {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .refresh-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .icon-button {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            transition: background 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .icon-button:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        #main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        #map {
            flex: 1;
            position: relative;
        }

        #search-container {
            position: absolute;
            top: 10px;
            left: 60px;
            z-index: 1000;
            display: flex;
            gap: 5px;
        }

        #search-input {
            width: 300px;
            padding: 10px 15px;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            background: var(--input-bg);
            color: var(--text-primary);
            box-shadow: 0 2px 10px var(--shadow);
        }

        #search-button {
            padding: 10px 20px;
            background: var(--button-primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 10px var(--shadow);
            transition: background 0.3s;
        }

        #search-button:hover {
            background: var(--button-primary-hover);
        }

        #control-panel {
            width: 320px;
            background: var(--control-panel-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-left: 1px solid var(--control-panel-border);
            overflow-y: auto;
            box-shadow: -2px 0 10px var(--shadow);
            z-index: 1000;
            transition: background 0.3s, border 0.3s;
        }

        .control-section {
            border-bottom: 1px solid var(--border-light);
        }

        .control-section-header {
            padding: 15px 20px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }

        .control-section-header:hover {
            background: var(--bg-secondary);
        }

        .control-section h3 {
            font-size: 16px;
            color: var(--text-primary);
            margin: 0;
            font-weight: 600;
        }

        .collapse-icon {
            font-size: 12px;
            color: var(--text-secondary);
            transition: transform 0.3s;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .control-section-content {
            padding: 0 20px 20px 20px;
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
        }

        .control-section-content.collapsed {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 5px;
            font-weight: 500;
        }

        select, input[type="range"], input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            background: var(--input-bg);
            color: var(--text-primary);
        }

        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--slider-thumb);
        }

        .button {
            background: var(--button-primary);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.3s;
            width: 100%;
            margin-top: 5px;
        }

        .button:hover {
            background: var(--button-primary-hover);
        }

        .button:active {
            transform: translateY(1px);
        }

        .button.secondary {
            background: var(--button-secondary);
        }

        .button.secondary:hover {
            background: var(--button-secondary-hover);
        }

        .layer-toggle {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-light);
        }

        .layer-toggle:last-child {
            border-bottom: none;
        }

        .layer-toggle input[type="checkbox"] {
            width: auto;
            margin-right: 10px;
            cursor: pointer;
        }

        .layer-toggle label {
            flex: 1;
            margin-bottom: 0;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-primary);
        }

        .layer-color-box {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-left: 8px;
            border: 1px solid var(--border-color);
        }

        #time-controls {
            display: none;
        }

        .time-display {
            background: var(--bg-secondary);
            padding: 10px;
            border-radius: 4px;
            text-align: center;
            font-weight: 500;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .play-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .play-controls .button {
            flex: 1;
            margin-top: 0;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            padding: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--slider-thumb);
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--slider-thumb);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .info-box {
            background: var(--info-bg);
            border-left: 3px solid var(--info-border);
            padding: 10px;
            margin-top: 10px;
            border-radius: 3px;
            font-size: 12px;
            color: var(--text-primary);
        }

        #colorbar {
            position: absolute;
            bottom: 30px;
            right: 20px;
            background: var(--control-panel-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px var(--shadow-strong);
            z-index: 1000;
            min-width: 200px;
            border: 1px solid var(--control-panel-border);
        }

        #colorbar-title {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        #colorbar-gradient {
            height: 20px;
            border-radius: 3px;
            margin-bottom: 5px;
        }

        .colorbar-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .leaflet-container {
            background: var(--leaflet-bg);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-primary);
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px var(--shadow);
            z-index: 10000;
            display: none;
        }

        #loading.show {
            display: block;
        }

        .spinner {
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--slider-thumb);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        canvas.visualization-layer {
            position: absolute;
            pointer-events: none;
        }

        /* Fullscreen styles */
        #map:-webkit-full-screen {
            width: 100%;
            height: 100%;
        }

        #map:-moz-full-screen {
            width: 100%;
            height: 100%;
        }

        #map:fullscreen {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>{{TITLE}}</h1>
        <div class="header-controls">
            <div id="auto-refresh-indicator">
                <div class="refresh-spinner"></div>
                <span id="refresh-countdown">Refreshing in <span id="countdown-value">--</span>s</span>
            </div>
            <button id="theme-toggle" class="icon-button" title="Toggle Dark Mode">
                <span id="theme-icon">üåô</span>
            </button>
            <button id="fullscreen-toggle" class="icon-button" title="Fullscreen">
                <span>‚õ∂</span>
            </button>
        </div>
    </div>

    <div id="main-container">
        <div id="map">
            <div id="search-container">
                <input type="text" id="search-input" placeholder="Search location (e.g., London, UK)...">
                <button id="search-button">üîç Search</button>
            </div>
        </div>

        <div id="control-panel">
            <div class="control-section">
                <div class="control-section-header" onclick="toggleSection(this)">
                    <h3>Variable Selection</h3>
                    <span class="collapse-icon">‚ñº</span>
                </div>
                <div class="control-section-content">
                    <div class="control-group">
                        <label for="variable-select">Primary Variable:</label>
                        <select id="variable-select"></select>
                    </div>
                    <div id="variable-info" class="info-box"></div>
                </div>
            </div>

            <div class="control-section">
                <div class="control-section-header" onclick="toggleSection(this)">
                    <h3>Layer Visibility</h3>
                    <span class="collapse-icon">‚ñº</span>
                </div>
                <div class="control-section-content">
                    <div id="layer-toggles"></div>
                    <div class="control-group">
                        <button class="button secondary" id="show-all-layers">Show All</button>
                        <button class="button secondary" id="hide-all-layers">Hide All</button>
                    </div>
                </div>
            </div>

            <div class="control-section" id="time-controls">
                <div class="control-section-header" onclick="toggleSection(this)">
                    <h3>Time Control</h3>
                    <span class="collapse-icon">‚ñº</span>
                </div>
                <div class="control-section-content">
                    <div class="time-display" id="time-display">--</div>
                    <div class="play-controls">
                        <button class="button secondary" id="play-pause">‚ñ∂ Play</button>
                        <button class="button secondary" id="step-back">‚óÑ</button>
                        <button class="button secondary" id="step-forward">‚ñ∫</button>
                    </div>
                    <div class="control-group">
                        <label for="time-slider">Time Step:</label>
                        <input type="range" id="time-slider" min="0" max="0" value="0">
                    </div>
                    <div class="control-group">
                        <label for="speed-slider">Animation Speed:</label>
                        <input type="range" id="speed-slider" min="100" max="2000" value="500" step="100">
                    </div>
                </div>
            </div>

            <div class="control-section">
                <div class="control-section-header" onclick="toggleSection(this)">
                    <h3>Visualization Settings</h3>
                    <span class="collapse-icon">‚ñº</span>
                </div>
                <div class="control-section-content">
                    <div class="control-group">
                        <label for="basemap-select">Base Map:</label>
                        <select id="basemap-select">
                            <option value="osm">OpenStreetMap</option>
                            <option value="topo">Topographic</option>
                            <option value="satellite">Satellite</option>
                            <option value="light">Light (CartoDB)</option>
                            <option value="dark">Dark (CartoDB)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="opacity-slider">Opacity:</label>
                        <input type="range" id="opacity-slider" min="0" max="100" value="70">
                    </div>
                    <div class="control-group" id="vector-scale-control" style="display: none;">
                        <label for="vector-scale-slider">Vector Scale: <span id="vector-scale-value">1.0</span>x</label>
                        <input type="range" id="vector-scale-slider" min="0.1" max="5.0" value="1.0" step="0.1">
                    </div>
                    <button class="button" id="reset-view">Reset View</button>
                </div>
            </div>
        </div>

        <div id="colorbar">
            <div id="colorbar-title">Value</div>
            <div id="colorbar-gradient"></div>
            <div class="colorbar-labels">
                <span id="colorbar-min">0</span>
                <span id="colorbar-max">100</span>
            </div>
        </div>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div>Rendering visualization...</div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet MiniMap -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-minimap/3.6.1/Control.MiniMap.min.js"></script>
    <!-- Leaflet Heat -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <!-- D3.js for contours, hexbin, voronoi -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Chroma.js for color scales -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"></script>

    <script>
        // Data from Python
        const DATA = {{DATA_JSON}};

        // Global state
        let map;
        let miniMap;
        let currentBaseLayer = null;
        let currentVariable = null;
        let currentTimeIndex = 0;
        let isPlaying = false;
        let playInterval = null;
        let visualizationLayers = {};
        let layerVisibility = {};
        let currentOpacity = 0.7;
        let currentVectorScale = 1.0;

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            initMiniMap();
            populateVariableSelect();
            createLayerToggles();
            setupEventListeners();
            loadVariable(Object.keys(DATA.variables)[0]);

            // Load theme preference
            const savedTheme = localStorage.getItem('theme') || 'light';
            if (savedTheme === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
                document.getElementById('theme-icon').textContent = '‚òÄÔ∏è';
            }

            // Setup auto-refresh if enabled
            if (DATA.auto_refresh && DATA.auto_refresh > 0) {
                setupAutoRefresh(DATA.auto_refresh);
            }
        });

        function initMap() {
            // Configure projection/CRS
            const crsOptions = getCRS(DATA.projection);

            map = L.map('map', {
                center: DATA.center,
                zoom: DATA.zoom,
                zoomControl: true,
                crs: crsOptions
            });

            currentBaseLayer = getBaseLayer('osm');
            currentBaseLayer.addTo(map);
        }

        function getCRS(projection) {
            // Return appropriate Leaflet CRS based on projection string
            const projections = {
                'EPSG3857': L.CRS.EPSG3857,  // Web Mercator (default)
                'EPSG4326': L.CRS.EPSG4326,  // WGS84 / Simple equirectangular
                'EPSG3395': L.CRS.EPSG3395,  // World Mercator
                'Simple': L.CRS.Simple        // Simple CRS for non-geographic maps
            };

            return projections[projection] || L.CRS.EPSG3857;
        }

        function initMiniMap() {
            // Create minimap with a different tile layer
            const miniMapLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                minZoom: 0,
                maxZoom: 13,
                attribution: ''
            });

            miniMap = new L.Control.MiniMap(miniMapLayer, {
                toggleDisplay: true,
                minimized: false,
                position: 'topright',
                width: 150,
                height: 150,
                collapsedWidth: 25,
                collapsedHeight: 25,
                zoomLevelOffset: -5,
                zoomAnimation: true
            }).addTo(map);
        }

        function getBaseLayer(type) {
            const baseLayers = {
                'osm': {
                    url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                    attribution: '¬© OpenStreetMap contributors',
                    maxZoom: 19
                },
                'topo': {
                    url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
                    attribution: 'Map data: ¬© OpenStreetMap contributors, SRTM | Map style: ¬© OpenTopoMap (CC-BY-SA)',
                    maxZoom: 17
                },
                'satellite': {
                    url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                    attribution: 'Tiles ¬© Esri',
                    maxZoom: 19
                },
                'light': {
                    url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
                    attribution: '¬© OpenStreetMap contributors ¬© CARTO',
                    maxZoom: 19,
                    subdomains: 'abcd'
                },
                'dark': {
                    url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
                    attribution: '¬© OpenStreetMap contributors ¬© CARTO',
                    maxZoom: 19,
                    subdomains: 'abcd'
                }
            };

            const config = baseLayers[type] || baseLayers['osm'];
            return L.tileLayer(config.url, {
                attribution: config.attribution,
                maxZoom: config.maxZoom,
                subdomains: config.subdomains || 'abc'
            });
        }

        function changeBaseMap(type) {
            if (currentBaseLayer) {
                map.removeLayer(currentBaseLayer);
            }

            currentBaseLayer = getBaseLayer(type);
            currentBaseLayer.addTo(map);
            currentBaseLayer.bringToBack();
        }

        function populateVariableSelect() {
            const select = document.getElementById('variable-select');
            Object.keys(DATA.variables).forEach(varName => {
                const option = document.createElement('option');
                option.value = varName;
                option.textContent = varName;
                select.appendChild(option);
            });
        }

        function createLayerToggles() {
            const container = document.getElementById('layer-toggles');
            const varNames = Object.keys(DATA.variables);

            varNames.forEach((varName, index) => {
                const variable = DATA.variables[varName];
                layerVisibility[varName] = index === 0;

                const toggleDiv = document.createElement('div');
                toggleDiv.className = 'layer-toggle';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `layer-${varName}`;
                checkbox.checked = layerVisibility[varName];
                checkbox.addEventListener('change', function() {
                    toggleLayerVisibility(varName, this.checked);
                });

                const label = document.createElement('label');
                label.htmlFor = `layer-${varName}`;
                label.textContent = varName;

                const colorBox = document.createElement('div');
                colorBox.className = 'layer-color-box';
                colorBox.style.background = getVariableColor(variable);

                toggleDiv.appendChild(checkbox);
                toggleDiv.appendChild(label);
                toggleDiv.appendChild(colorBox);
                container.appendChild(toggleDiv);
            });
        }

        function getVariableColor(variable) {
            const colormaps = {
                'viridis': '#440154',
                'plasma': '#0d0887',
                'jet': '#0000ff',
                'rainbow': '#9400d3',
                'cool': '#00ffff',
                'hot': '#ff0000'
            };
            return colormaps[variable.colormap] || '#667eea';
        }

        function setupEventListeners() {
            document.getElementById('variable-select').addEventListener('change', function() {
                loadVariable(this.value);
            });

            document.getElementById('basemap-select').addEventListener('change', function() {
                changeBaseMap(this.value);
            });

            document.getElementById('time-slider').addEventListener('input', function() {
                currentTimeIndex = parseInt(this.value);
                updateVisualization();
            });

            document.getElementById('opacity-slider').addEventListener('input', function() {
                updateOpacity(this.value / 100);
            });

            document.getElementById('vector-scale-slider').addEventListener('input', function() {
                currentVectorScale = parseFloat(this.value);
                document.getElementById('vector-scale-value').textContent = currentVectorScale.toFixed(1);
                updateVectorLayers();
            });

            document.getElementById('play-pause').addEventListener('click', togglePlay);
            document.getElementById('step-back').addEventListener('click', stepBack);
            document.getElementById('step-forward').addEventListener('click', stepForward);
            document.getElementById('reset-view').addEventListener('click', resetView);

            document.getElementById('speed-slider').addEventListener('input', function() {
                if (isPlaying) {
                    stopAnimation();
                    startAnimation();
                }
            });

            document.getElementById('show-all-layers').addEventListener('click', function() {
                Object.keys(DATA.variables).forEach(varName => {
                    layerVisibility[varName] = true;
                    document.getElementById(`layer-${varName}`).checked = true;
                    if (!visualizationLayers[varName]) {
                        renderLayer(varName);
                    } else {
                        map.addLayer(visualizationLayers[varName]);
                    }
                });
            });

            document.getElementById('hide-all-layers').addEventListener('click', function() {
                Object.keys(DATA.variables).forEach(varName => {
                    layerVisibility[varName] = false;
                    document.getElementById(`layer-${varName}`).checked = false;
                    if (visualizationLayers[varName]) {
                        map.removeLayer(visualizationLayers[varName]);
                    }
                });
            });

            // Theme toggle
            document.getElementById('theme-toggle').addEventListener('click', toggleTheme);

            // Fullscreen toggle
            document.getElementById('fullscreen-toggle').addEventListener('click', toggleFullscreen);

            // Search functionality
            document.getElementById('search-button').addEventListener('click', performSearch);
            document.getElementById('search-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    performSearch();
                }
            });
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

            document.documentElement.setAttribute('data-theme', newTheme);
            document.getElementById('theme-icon').textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            localStorage.setItem('theme', newTheme);
        }

        function toggleFullscreen() {
            const mapElement = document.getElementById('map');

            if (!document.fullscreenElement) {
                if (mapElement.requestFullscreen) {
                    mapElement.requestFullscreen();
                } else if (mapElement.mozRequestFullScreen) {
                    mapElement.mozRequestFullScreen();
                } else if (mapElement.webkitRequestFullscreen) {
                    mapElement.webkitRequestFullscreen();
                } else if (mapElement.msRequestFullscreen) {
                    mapElement.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }

            // Give the map time to adjust to new size
            setTimeout(() => map.invalidateSize(), 100);
        }

        async function performSearch() {
            const query = document.getElementById('search-input').value.trim();
            if (!query) return;

            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`
                );
                const results = await response.json();

                if (results.length > 0) {
                    const result = results[0];
                    const lat = parseFloat(result.lat);
                    const lon = parseFloat(result.lon);

                    map.setView([lat, lon], 10);

                    // Add temporary marker
                    const marker = L.marker([lat, lon])
                        .addTo(map)
                        .bindPopup(result.display_name)
                        .openPopup();

                    // Remove marker after 5 seconds
                    setTimeout(() => map.removeLayer(marker), 5000);
                } else {
                    alert('Location not found. Please try a different search term.');
                }
            } catch (error) {
                console.error('Search error:', error);
                alert('Search failed. Please check your internet connection.');
            }
        }

        function loadVariable(varName) {
            showLoading();
            currentVariable = DATA.variables[varName];
            currentTimeIndex = 0;

            const infoBox = document.getElementById('variable-info');
            infoBox.innerHTML = `
                <strong>Type:</strong> ${currentVariable.plot_type}<br>
                <strong>Shape:</strong> ${currentVariable.shape.join(' √ó ')}<br>
                <strong>Range:</strong> ${currentVariable.vmin.toFixed(2)} - ${currentVariable.vmax.toFixed(2)} ${currentVariable.units}
            `;

            const numTimesteps = currentVariable.shape[0];
            if (numTimesteps > 1) {
                document.getElementById('time-controls').style.display = 'block';
                document.getElementById('time-slider').max = numTimesteps - 1;
                document.getElementById('time-slider').value = 0;
            } else {
                document.getElementById('time-controls').style.display = 'none';
            }

            updateColorbar();

            if (layerVisibility[varName]) {
                renderLayer(varName);
            }

            hideLoading();
        }

        function updateVisualization() {
            showLoading();

            if (currentVariable.timestamps.length > 1) {
                const timestamp = new Date(currentVariable.timestamps[currentTimeIndex]);
                document.getElementById('time-display').textContent = timestamp.toLocaleString();
            }

            Object.keys(DATA.variables).forEach(varName => {
                if (layerVisibility[varName]) {
                    renderLayer(varName);
                }
            });

            hideLoading();
        }

        function toggleLayerVisibility(varName, visible) {
            layerVisibility[varName] = visible;

            if (visible) {
                renderLayer(varName);
            } else {
                if (visualizationLayers[varName]) {
                    map.removeLayer(visualizationLayers[varName]);
                }
            }

            updateVectorScaleVisibility();
        }

        function updateVectorScaleVisibility() {
            let hasVectorLayer = false;
            Object.keys(DATA.variables).forEach(varName => {
                if (layerVisibility[varName]) {
                    const variable = DATA.variables[varName];
                    if (variable.plot_type === 'vector' || variable.plot_type === 'stream') {
                        hasVectorLayer = true;
                    }
                }
            });

            const control = document.getElementById('vector-scale-control');
            if (hasVectorLayer) {
                control.style.display = 'block';
            } else {
                control.style.display = 'none';
            }
        }

        function updateVectorLayers() {
            Object.keys(DATA.variables).forEach(varName => {
                if (layerVisibility[varName]) {
                    const variable = DATA.variables[varName];
                    if (variable.plot_type === 'vector' || variable.plot_type === 'stream') {
                        renderLayer(varName);
                    }
                }
            });
        }

        function renderLayer(varName) {
            const variable = DATA.variables[varName];

            if (visualizationLayers[varName]) {
                map.removeLayer(visualizationLayers[varName]);
            }

            switch (variable.plot_type) {
                case 'scatter':
                case 'scatter_colored':
                    renderScatter(varName, variable);
                    break;
                case 'hexbin':
                    renderHexbin(varName, variable);
                    break;
                case 'heatmap':
                    renderHeatmap(varName, variable);
                    break;
                case 'voronoi':
                    renderVoronoi(varName, variable);
                    break;
                case 'isosurface':
                    renderIsosurface(varName, variable);
                    break;
                case 'contour':
                    renderContour(varName, variable, false);
                    break;
                case 'filled_contour':
                    renderContour(varName, variable, true);
                    break;
                case 'vector':
                    renderVector(varName, variable);
                    break;
                case 'stream':
                    renderStream(varName, variable);
                    break;
            }
        }

        function renderScatter(varName, variable) {
            const lon = variable.lon;
            const lat = variable.lat;
            const data = variable.data[currentTimeIndex];

            const colorScale = getColorScale(variable);
            const points = [];

            for (let i = 0; i < lat.length; i++) {
                for (let j = 0; j < lat[i].length; j++) {
                    if (!isNaN(data[i][j])) {
                        const value = data[i][j];
                        const color = colorScale(value);

                        const circle = L.circleMarker([lat[i][j], lon[i][j]], {
                            radius: 4,
                            fillColor: color,
                            fillOpacity: currentOpacity,
                            color: color,
                            weight: 1,
                            opacity: currentOpacity
                        });

                        circle.bindPopup(`${varName}: ${value.toFixed(2)} ${variable.units}`);
                        points.push(circle);
                    }
                }
            }

            visualizationLayers[varName] = L.layerGroup(points).addTo(map);
        }

        function renderHexbin(varName, variable) {
            const lon = variable.lon;
            const lat = variable.lat;
            const data = variable.data[currentTimeIndex];

            const colorScale = getColorScale(variable);

            // Collect all points
            const points = [];
            for (let i = 0; i < lat.length; i++) {
                for (let j = 0; j < lat[i].length; j++) {
                    if (!isNaN(data[i][j])) {
                        points.push({
                            lat: lat[i][j],
                            lon: lon[i][j],
                            value: data[i][j]
                        });
                    }
                }
            }

            // Group points into hexagonal bins
            const hexRadius = 0.5; // degrees
            const hexbins = {};

            points.forEach(pt => {
                // Simple hexagonal binning
                const hexX = Math.round(pt.lon / hexRadius);
                const hexY = Math.round(pt.lat / (hexRadius * Math.sqrt(3) / 2));
                const key = `${hexX},${hexY}`;

                if (!hexbins[key]) {
                    hexbins[key] = {
                        centerLon: hexX * hexRadius,
                        centerLat: hexY * hexRadius * Math.sqrt(3) / 2,
                        values: []
                    };
                }
                hexbins[key].values.push(pt.value);
            });

            // Create hexagon polygons
            const hexagons = [];
            Object.values(hexbins).forEach(bin => {
                const avgValue = bin.values.reduce((a, b) => a + b, 0) / bin.values.length;
                const color = colorScale(avgValue);

                // Create hexagon vertices
                const vertices = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const vertexLat = bin.centerLat + hexRadius * 0.5 * Math.sin(angle);
                    const vertexLon = bin.centerLon + hexRadius * 0.5 * Math.cos(angle);
                    vertices.push([vertexLat, vertexLon]);
                }

                const hexagon = L.polygon(vertices, {
                    fillColor: color,
                    fillOpacity: currentOpacity,
                    color: color,
                    weight: 1,
                    opacity: currentOpacity * 0.5
                });

                hexagon.bindPopup(`${varName}: ${avgValue.toFixed(2)} ${variable.units}<br>Count: ${bin.values.length}`);
                hexagons.push(hexagon);
            });

            visualizationLayers[varName] = L.layerGroup(hexagons).addTo(map);
        }

        function renderHeatmap(varName, variable) {
            const lon = variable.lon;
            const lat = variable.lat;
            const data = variable.data[currentTimeIndex];

            // Collect points with intensity
            const points = [];
            for (let i = 0; i < lat.length; i++) {
                for (let j = 0; j < lat[i].length; j++) {
                    if (!isNaN(data[i][j])) {
                        // Normalize value to 0-1 for intensity
                        const normalized = (data[i][j] - variable.vmin) / (variable.vmax - variable.vmin);
                        points.push([lat[i][j], lon[i][j], normalized]);
                    }
                }
            }

            visualizationLayers[varName] = L.heatLayer(points, {
                radius: 25,
                blur: 15,
                maxZoom: 10,
                max: 1.0,
                gradient: {
                    0.0: 'blue',
                    0.25: 'cyan',
                    0.5: 'lime',
                    0.75: 'yellow',
                    1.0: 'red'
                }
            }).addTo(map);
        }

        function renderVoronoi(varName, variable) {
            const lon = variable.lon;
            const lat = variable.lat;
            const data = variable.data[currentTimeIndex];

            const colorScale = getColorScale(variable);

            // Subsample points for cleaner visualization
            const step = Math.max(1, Math.floor(lon[0].length / 30));
            const points = [];

            for (let i = 0; i < lat.length; i += step) {
                for (let j = 0; j < lat[i].length; j += step) {
                    if (!isNaN(data[i][j])) {
                        points.push({
                            coords: [lon[i][j], lat[i][j]],
                            value: data[i][j]
                        });
                    }
                }
            }

            // Calculate bounds
            const lons = points.map(p => p.coords[0]);
            const lats = points.map(p => p.coords[1]);
            const extent = [
                [Math.min(...lons), Math.min(...lats)],
                [Math.max(...lons), Math.max(...lats)]
            ];

            // Create Voronoi diagram using D3
            const delaunay = d3.Delaunay.from(points.map(p => p.coords));
            const voronoi = delaunay.voronoi([
                extent[0][0], extent[0][1],
                extent[1][0], extent[1][1]
            ]);

            const polygons = [];
            points.forEach((point, i) => {
                const cell = voronoi.cellPolygon(i);
                if (cell) {
                    const color = colorScale(point.value);
                    // Convert to [lat, lon] for Leaflet
                    const leafletCoords = cell.map(c => [c[1], c[0]]);

                    const polygon = L.polygon(leafletCoords, {
                        fillColor: color,
                        fillOpacity: currentOpacity,
                        color: color,
                        weight: 1,
                        opacity: currentOpacity * 0.7
                    });

                    polygon.bindPopup(`${varName}: ${point.value.toFixed(2)} ${variable.units}`);
                    polygons.push(polygon);
                }
            });

            visualizationLayers[varName] = L.layerGroup(polygons).addTo(map);
        }

        function renderIsosurface(varName, variable) {
            const lon = variable.lon;
            const lat = variable.lat;
            const data = variable.data[currentTimeIndex];

            const colorScale = getColorScale(variable);
            const numLevels = 5; // Multiple layers for 3D effect
            const layers = [];

            // Create multiple contour levels with offset shadows
            for (let level = 0; level < numLevels; level++) {
                const levelMin = variable.vmin + (variable.vmax - variable.vmin) * level / numLevels;
                const levelMax = variable.vmin + (variable.vmax - variable.vmin) * (level + 1) / numLevels;

                const thresholds = [levelMin, (levelMin + levelMax) / 2, levelMax];
                const contours = d3.contours()
                    .size([lon[0].length, lon.length])
                    .thresholds(thresholds);

                const contourData = contours(data.flat());

                contourData.forEach(contour => {
                    const coordinates = contour.coordinates.map(polygon => {
                        return polygon.map(ring => {
                            return ring.map(point => {
                                const j = Math.floor(point[0]);
                                const i = Math.floor(point[1]);
                                const ni = Math.min(i, lat.length - 1);
                                const nj = Math.min(j, lon[0].length - 1);
                                return [lat[ni][nj], lon[ni][nj]];
                            });
                        });
                    });

                    const value = contour.value;
                    const color = colorScale(value);

                    // Create shadow effect
                    const shadowOpacity = currentOpacity * (0.3 + 0.7 * level / numLevels);

                    coordinates.forEach(poly => {
                        const leafletPoly = L.polygon(poly, {
                            fillColor: color,
                            fillOpacity: shadowOpacity,
                            color: color,
                            weight: 2,
                            opacity: shadowOpacity,
                            className: `isosurface-level-${level}`
                        });

                        leafletPoly.bindPopup(`${varName}: ${value.toFixed(2)} ${variable.units}`);
                        layers.push(leafletPoly);
                    });
                });
            }

            visualizationLayers[varName] = L.layerGroup(layers).addTo(map);
        }

        function renderContour(varName, variable, filled) {
            const lon = variable.lon;
            const lat = variable.lat;
            const data = variable.data[currentTimeIndex];

            const colorScale = getColorScale(variable);
            const thresholds = d3.range(
                variable.vmin,
                variable.vmax,
                (variable.vmax - variable.vmin) / variable.levels
            );

            const contours = d3.contours()
                .size([lon[0].length, lon.length])
                .thresholds(thresholds);

            const contourData = contours(data.flat());

            const polygons = [];

            contourData.forEach(contour => {
                const coordinates = contour.coordinates.map(polygon => {
                    return polygon.map(ring => {
                        return ring.map(point => {
                            const j = Math.floor(point[0]);
                            const i = Math.floor(point[1]);
                            const ni = Math.min(i, lat.length - 1);
                            const nj = Math.min(j, lon[0].length - 1);
                            return [lat[ni][nj], lon[ni][nj]];
                        });
                    });
                });

                const value = contour.value;
                const color = colorScale(value);

                coordinates.forEach(poly => {
                    const leafletPoly = L.polygon(poly, {
                        fillColor: filled ? color : 'none',
                        fillOpacity: filled ? currentOpacity : 0,
                        color: color,
                        weight: filled ? 0 : 2,
                        opacity: filled ? 0 : currentOpacity
                    });

                    leafletPoly.bindPopup(`${varName}: ${value.toFixed(2)} ${variable.units}`);
                    polygons.push(leafletPoly);
                });
            });

            visualizationLayers[varName] = L.layerGroup(polygons).addTo(map);
        }

        function renderVector(varName, variable) {
            const lon = variable.lon;
            const lat = variable.lat;
            const u = variable.u_component[currentTimeIndex];
            const v = variable.v_component[currentTimeIndex];

            const colorScale = getColorScale(variable);
            const arrows = [];

            const step = Math.max(1, Math.floor(lon[0].length / 30));

            for (let i = 0; i < lat.length; i += step) {
                for (let j = 0; j < lat[i].length; j += step) {
                    if (!isNaN(u[i][j]) && !isNaN(v[i][j])) {
                        const magnitude = Math.sqrt(u[i][j] ** 2 + v[i][j] ** 2);
                        const color = colorScale(magnitude);

                        const baseScale = 0.5;
                        const scale = baseScale * variable.vector_scale * currentVectorScale;
                        const dx = u[i][j] * scale;
                        const dy = v[i][j] * scale;

                        const startLat = lat[i][j];
                        const startLon = lon[i][j];
                        const endLat = startLat + dy * 0.01;
                        const endLon = startLon + dx * 0.01;

                        const arrow = L.polyline(
                            [[startLat, startLon], [endLat, endLon]],
                            {
                                color: color,
                                weight: 2,
                                opacity: currentOpacity
                            }
                        );

                        arrow.bindPopup(`${varName}: ${magnitude.toFixed(2)} ${variable.units}`);
                        arrows.push(arrow);
                    }
                }
            }

            visualizationLayers[varName] = L.layerGroup(arrows).addTo(map);
        }

        function renderStream(varName, variable) {
            const lon = variable.lon;
            const lat = variable.lat;
            const u = variable.u_component[currentTimeIndex];
            const v = variable.v_component[currentTimeIndex];

            const colorScale = getColorScale(variable);
            const lines = [];

            const numSeeds = 50;
            const step = Math.floor(lon[0].length / Math.sqrt(numSeeds));

            for (let i = step; i < lat.length; i += step) {
                for (let j = step; j < lat[i].length; j += step) {
                    const streamline = traceStreamline(i, j, u, v, lat, lon);
                    if (streamline.length > 2) {
                        const avgMagnitude = streamline.reduce((sum, pt) => sum + pt.mag, 0) / streamline.length;
                        const color = colorScale(avgMagnitude);

                        const coords = streamline.map(pt => [pt.lat, pt.lon]);
                        const line = L.polyline(coords, {
                            color: color,
                            weight: 2,
                            opacity: currentOpacity
                        });

                        line.bindPopup(`${varName}: ${avgMagnitude.toFixed(2)} ${variable.units}`);
                        lines.push(line);
                    }
                }
            }

            visualizationLayers[varName] = L.layerGroup(lines).addTo(map);
        }

        function traceStreamline(startI, startJ, u, v, lat, lon, maxSteps = 50) {
            const streamline = [];
            let i = startI;
            let j = startJ;

            for (let step = 0; step < maxSteps; step++) {
                if (i < 0 || i >= lat.length - 1 || j < 0 || j >= lon[0].length - 1) break;

                const ui = u[i][j];
                const vi = v[i][j];

                if (isNaN(ui) || isNaN(vi)) break;

                const magnitude = Math.sqrt(ui ** 2 + vi ** 2);
                streamline.push({
                    lat: lat[i][j],
                    lon: lon[i][j],
                    mag: magnitude
                });

                const di = vi * 0.5;
                const dj = ui * 0.5;

                i = Math.round(i + di);
                j = Math.round(j + dj);
            }

            return streamline;
        }

        function getColorScale(variable) {
            const colormap = variable.colormap;
            const vmin = variable.vmin;
            const vmax = variable.vmax;

            let scale;
            switch (colormap) {
                case 'viridis':
                    scale = chroma.scale(['#440154', '#414487', '#2a788e', '#22a884', '#7ad151', '#fde724']);
                    break;
                case 'plasma':
                    scale = chroma.scale(['#0d0887', '#6a00a8', '#b12a90', '#e16462', '#fca636', '#f0f921']);
                    break;
                case 'jet':
                    scale = chroma.scale(['blue', 'cyan', 'lime', 'yellow', 'red']);
                    break;
                case 'rainbow':
                    scale = chroma.scale(['purple', 'blue', 'green', 'yellow', 'orange', 'red']);
                    break;
                case 'cool':
                    scale = chroma.scale(['cyan', 'magenta']);
                    break;
                case 'hot':
                    scale = chroma.scale(['black', 'red', 'yellow', 'white']);
                    break;
                default:
                    scale = chroma.scale('YlOrRd');
            }

            return (value) => {
                const normalized = (value - vmin) / (vmax - vmin);
                return scale(Math.max(0, Math.min(1, normalized))).hex();
            };
        }

        function updateColorbar() {
            document.getElementById('colorbar-title').textContent =
                `${document.getElementById('variable-select').value} (${currentVariable.units})`;

            const gradient = getColorScale(currentVariable);
            const steps = 20;
            let gradientCSS = 'linear-gradient(to right';
            for (let i = 0; i <= steps; i++) {
                const value = currentVariable.vmin + (currentVariable.vmax - currentVariable.vmin) * i / steps;
                const color = gradient(value);
                gradientCSS += `, ${color}`;
            }
            gradientCSS += ')';

            document.getElementById('colorbar-gradient').style.background = gradientCSS;
            document.getElementById('colorbar-min').textContent = currentVariable.vmin.toFixed(2);
            document.getElementById('colorbar-max').textContent = currentVariable.vmax.toFixed(2);
        }

        function updateOpacity(opacity) {
            currentOpacity = opacity;
            Object.keys(visualizationLayers).forEach(varName => {
                if (visualizationLayers[varName]) {
                    visualizationLayers[varName].eachLayer(layer => {
                        if (layer.setStyle) {
                            layer.setStyle({ fillOpacity: opacity, opacity: opacity });
                        }
                    });
                }
            });
        }

        function togglePlay() {
            if (isPlaying) {
                stopAnimation();
            } else {
                startAnimation();
            }
        }

        function startAnimation() {
            isPlaying = true;
            document.getElementById('play-pause').textContent = '‚è∏ Pause';
            const speed = parseInt(document.getElementById('speed-slider').value);

            playInterval = setInterval(() => {
                currentTimeIndex = (currentTimeIndex + 1) % currentVariable.shape[0];
                document.getElementById('time-slider').value = currentTimeIndex;
                updateVisualization();
            }, 2100 - speed);
        }

        function stopAnimation() {
            isPlaying = false;
            document.getElementById('play-pause').textContent = '‚ñ∂ Play';
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
            }
        }

        function stepBack() {
            if (currentTimeIndex > 0) {
                currentTimeIndex--;
                document.getElementById('time-slider').value = currentTimeIndex;
                updateVisualization();
            }
        }

        function stepForward() {
            if (currentTimeIndex < currentVariable.shape[0] - 1) {
                currentTimeIndex++;
                document.getElementById('time-slider').value = currentTimeIndex;
                updateVisualization();
            }
        }

        function resetView() {
            map.setView(DATA.center, DATA.zoom);
        }

        function showLoading() {
            document.getElementById('loading').classList.add('show');
        }

        function hideLoading() {
            setTimeout(() => {
                document.getElementById('loading').classList.remove('show');
            }, 300);
        }

        function setupAutoRefresh(intervalSeconds) {
            const indicator = document.getElementById('auto-refresh-indicator');
            const countdownValue = document.getElementById('countdown-value');

            // Show the indicator
            indicator.classList.add('active');

            let remainingSeconds = intervalSeconds;

            // Update countdown every second
            const countdownInterval = setInterval(() => {
                remainingSeconds--;
                countdownValue.textContent = remainingSeconds;

                if (remainingSeconds <= 0) {
                    remainingSeconds = intervalSeconds;
                }
            }, 1000);

            // Set initial countdown
            countdownValue.textContent = intervalSeconds;

            // Auto-refresh at specified interval
            setInterval(() => {
                console.log('Auto-refreshing page...');
                location.reload();
            }, intervalSeconds * 1000);

            console.log(`Auto-refresh enabled: ${intervalSeconds} seconds`);
        }

        function toggleSection(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.collapse-icon');

            content.classList.toggle('collapsed');
            icon.classList.toggle('collapsed');
        }

        // Smooth interpolation helper function
        function interpolateData(data1, data2, fraction) {
            // Linearly interpolate between two 2D data arrays
            const result = [];
            for (let i = 0; i < data1.length; i++) {
                result[i] = [];
                for (let j = 0; j < data1[i].length; j++) {
                    if (isNaN(data1[i][j]) || isNaN(data2[i][j])) {
                        result[i][j] = data1[i][j];  // Keep original if NaN
                    } else {
                        result[i][j] = data1[i][j] * (1 - fraction) + data2[i][j] * fraction;
                    }
                }
            }
            return result;
        }
    </script>
</body>
</html>
